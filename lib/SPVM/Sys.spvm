# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Sys {
  version "0.486";
  
  use Sys::OS;
  use Sys::Env;
  use Sys::FileTest;
  use Sys::Ioctl;
  use Sys::User;
  use Sys::Time;
  use Sys::Process;
  use Sys::IO::Stat;
  use Sys::Socket;
  use Sys::Select;
  use Sys::IO::FileStream;
  
  static method osname : string () {
    my $osname : string;
    
    if (Sys::OS->defined("__linux__")) {
      $osname = "linux";
    }
    elsif (Sys::OS->defined("_WIN32")) {
      $osname = "MSWin32";
    }
    elsif (Sys::OS->defined("__FreeBSD__")) {
      $osname = "freebsd";
    }
    elsif (Sys::OS->defined("__OpenBSD__")) {
      $osname = "openbsd";
    }
    elsif (Sys::OS->defined("__solaris")) {
      $osname = "solaris";
    }
    elsif (Sys::OS->defined("__sun")) {
      $osname = "solaris";
    }
    elsif (Sys::OS->defined("__APPLE__")) {
      $osname = "darwin";
    }
    else {
      die "The osname method is not supported this os";
    }
    
    return $osname;
  }
  
  static method env : string ($name : string) {
    my $env_value = Sys::Env->getenv($name);
    return $env_value;
  }
  
  static method A : double ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys->stat($file);
    
    my $result_time = $stat->A;
    
    return $result_time;
  }
  
  static method C : double ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys->stat($file);
    my $result_time = $stat->C;
    
    return $result_time;
  }
  
  static method M : double ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys->stat($file);
    
    my $result_time = $stat->M;
    
    return $result_time;
  }
  
  static method O : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->O;
    }
    
    return $ok;
  }
  
  static method R : int ($file : string) {
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Character device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->R;
    }
    
    return $ok;
  }
  
  static method S : int ($file : string) {
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys->stat($file);
    
    my $ok = $stat->S;
    
    return $ok;
  }
  
  static method W : int ($file : string) {
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Character device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->W;
    }
    
    return $ok;
  }
  
  static method X : int ($file : string) {
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Character device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->X;
    }
    
    return $ok;
  }
  
  static method b : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Block device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->b;
    }
    
    return $ok;
  }
  
  static method c : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Character device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->c;
    }
    
    return $ok;
  }
  
  static method d : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->d;
    }
    
    return $ok;
  }
  
  static method e : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->e;
    }
    
    return $ok;
  }
  
  static method f : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->f;
    }
    
    return $ok;
  }
  
  static method g : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->g;
    }
    
    return $ok;
  }
  
  static method k : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->k;
    }
    
    return $ok;
  }
  
  static method l : int ($file : string) {
    
    my $ok = 0;
    
    unless ($file) {
      die "The file must be defined";
    }
    
    if (Sys::OS->is_windows) {
      $ok = Sys::IO::Windows->is_symlink($file);
    }
    else {
      my $stat = Sys::IO::Stat->new;
      my $status = Sys::IO::Stat->lstat_raw($file, $stat);
      
      unless ($status == -1) {
        $ok = $stat->l;
      }
    }
    
    return $ok;
  }
  
  static method o : int ($file : string) {
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->o;
    }
    return $ok;
  }
  
  static method p : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # FIFO/PIPE
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->p;
    }
    
    return $ok;
  }
  
  static method r : int ($file : string) {
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Character device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->r;
    }
    
    return $ok;
  }
  
  static method s : long ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys->stat($file);
    
    my $size = $stat->s;
    
    return $size;
  }
  
  static method u : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Character device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->u;
    }
    
    return $ok;
  }
  
  static method w : int ($file : string) {
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Character device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->w;
    }
    
    return $ok;
  }
  
  static method x : int ($file : string) {
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys::IO::Stat->new;
    my $status = Sys::IO::Stat->stat_raw($file, $stat);
    
    # Character device
    my $ok = 0;
    unless ($status == -1) {
      $ok = $stat->x;
    }
    
    return $ok;
  }
  
  static method z : int ($file : string) {
    
    unless ($file) {
      die "The file must be defined";
    }
    
    my $stat = Sys->stat($file);
    
    my $ok = $stat->z;
    
    return $ok;
  }
  
  static method time : long () {
    my $time = Sys::Time->time();
    return $time;
  }
  
  static method localtime : Sys::Time::Tm ($time : long) {
    my $tm = Sys::Time->localtime($time);
    return $tm;
  }
  
  static method gmtime : Sys::Time::Tm ($time : long) {
    my $tm = Sys::Time->gmtime($time);
    return $tm;
  }
  
  static method process_id : int () {
    my $process_id = Sys::Process->getpid();
    return $process_id;
  }
  
  static method stat : Sys::IO::Stat ($path : string) {
    my $stat = Sys::IO::Stat->new;
    Sys::IO::Stat->stat($path, $stat);
    return $stat;
  }
  
  static method fstat : Sys::IO::Stat ($fd : int) {
    my $stat = Sys::IO::Stat->new;
    Sys::IO::Stat->fstat($fd, $stat);
    return $stat;
  }
  
  static method chdir : int ($path : string) {
    my $status = Sys::IO->chdir($path);
    my $success = $status == 0;
    return $success;
  }
  
  static method chmod : int ($mode :int, $path : string) {
    my $status = Sys::IO->chmod($path, $mode);
    my $success = $status == 0;
    return $success;
  }
  
  static method mkdir : int ($path : string, $mode : int) {
    my $status = Sys::IO->mkdir($path, $mode);
    my $success = $status == 0;
    return $success;
  }
  
  static method umask : int ($mode : int) {
    my $current_umask = Sys::IO->umask($mode);
    
    return $current_umask;
  }
  
  static method rmdir : int ($path : string) {
    my $status = Sys::IO->rmdir($path);
    my $success = $status == 0;
    return $success;
  }
  
  static method opendir : int ($dh_ref : Sys::IO::DirStream[], $dir : string) {
    
    my $dh = Sys::IO->opendir($dir);
    
    $dh_ref->[0] = $dh;
    
    my $success = !($dh == undef);
    
    return $success;
  }
  
  static method closedir : int ($dirp : Sys::IO::DirStream) {
    my $status = Sys::IO->closedir($dirp);
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method unlink : int ($pathname : string) {
    my $status = 0;
    
    if (Sys::OS->is_windows) {
      $status = Sys::IO::Windows->unlink($pathname);
    }
    else {
      $status = Sys::IO->unlink($pathname);
    }
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method rename : int ($oldpath : string, $newpath : string) {
    my $status = 0;
    if (Sys::OS->is_windows) {
      $status = Sys::IO::Windows->rename($oldpath, $newpath);
    }
    else {
      $status = Sys::IO->rename($oldpath, $newpath);
    }
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method readlink : string ($file : string) {
    if (Sys::OS->is_windows) {
      my $buffer_size = Sys::IO::Windows->get_readlink_buffer_size($file);
      my $buffer = (mutable string)new_string_len $buffer_size;
      Sys::IO::Windows->readlink($file, $buffer, $buffer_size);
      return $buffer;
    }
    else {
      my $buffer_size = Sys::IO->get_readlink_buffer_size($file);
      my $buffer = (mutable string)new_string_len $buffer_size;
      Sys::IO->readlink($file, $buffer, $buffer_size);
      return $buffer;
    }
  }
  
  static method symlink : int ($oldpath : string, $newpath : string) {
    my $status = 0;
    if (Sys::OS->is_windows) {
      $status = Sys::IO::Windows->symlink($oldpath, $newpath);
    }
    else {
      $status = Sys::IO->symlink($oldpath, $newpath);
    }
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method sleep : int ($seconds : int) {
    my $slept_number = Sys::Process->sleep($seconds);
    return $slept_number;
  }
  
  static method ioctl : int ($fd : int, $request : int, $request_arg_ref : object of byte[]|short[]|int[]|long[]|float[]|double[]|object = undef) {
    my $ioctl_ret = -1;
    
    if (Sys::OS->is_windows) {
      $ioctl_ret = Sys::Ioctl->ioctlsocket($fd, $request, (int[])$request_arg_ref);
    }
    else {
      $ioctl_ret = Sys::Ioctl->ioctl($fd, $request, $request_arg_ref);
    }
    
    return $ioctl_ret;
  }
  
  static method select : int ($readfds : Sys::Select::Fd_set, $writefds : Sys::Select::Fd_set, $exceptfds : Sys::Select::Fd_set, $timeout : Sys::Time::Timeval) {
    my $nfds = 1024;
    my $fd_number = Sys::Select->select($nfds, $readfds, $writefds, $exceptfds, $timeout);
    return $fd_number;
  }
  
  static method bind : int ($sockfd : int, $addr : Sys::Socket::Sockaddr) {
    my $addrlen = $addr->size;
    my $status = Sys::Socket->bind($sockfd, $addr, $addrlen);
    my $success = $status == 0;
    return $success;
  }
  
  static method listen : int ($sockfd : int, $backlog : int) {
    my $status = Sys::Socket->listen($sockfd, $backlog);
    my $success = $status == 0;
    return $success;
  }
  
  static method accept : Sys::Socket::Sockaddr ($new_sockfd_ref : int*, $sockfd : int) {
    my $addrlen = 128;
    
    my $addr = Sys::Socket::Sockaddr->new;
    
    $$new_sockfd_ref = Sys::Socket->accept($sockfd, $addr, \$addrlen);
    
    my $addr_child = Sys::Socket->to_family_sockaddr($addr);
    
    return $addr_child;
  }
  
  static method connect : int ($sockfd : int, $addr : Sys::Socket::Sockaddr) {
    my $addrlen = $addr->size;
    my $status = Sys::Socket->connect($sockfd, $addr, $addrlen);
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method getpeername : Sys::Socket::Sockaddr ($sockfd : int) {
    my $addrlen = 128;
    
    my $addr = Sys::Socket::Sockaddr->new;
    
    my $status = Sys::Socket->getpeername($sockfd, $addr, \$addrlen);
    
    my $addr_child = Sys::Socket->to_family_sockaddr($addr);
    
    return $addr_child;
  }
  
  static method getsockname : Sys::Socket::Sockaddr ($sockfd : int) {
    
    my $addrlen = 128;
    
    my $addr = Sys::Socket::Sockaddr->new;
    
    my $status = Sys::Socket->getsockname($sockfd, $addr, \$addrlen);
    
    my $addr_child = Sys::Socket->to_family_sockaddr($addr);
    
    return $addr_child;
  }
  
  static method recv : int ($sockfd : int, $buf : mutable string, $len : int, $flags : int, $buf_offset : int = 0) {
    my $recv_length = Sys::Socket->recv($sockfd, $buf, $len, $flags, $buf_offset);
    
    return $recv_length;
  }
  
  static method send : int ($sockfd : int, $buf : string, $flags : int, $addr : Sys::Socket::Sockaddr = undef) {
    my $send_length = -1;
    
    if ($addr) {
      $send_length = Sys::Socket->sendto($sockfd, $buf, length $buf, $flags, $addr, $addr->size);
    }
    else {
      $send_length = Sys::Socket->send($sockfd, $buf, length $buf, $flags);
    }
    
    return $send_length;
  }
  
  static method shutdown : int ($sockfd : int, $how : int) {
    my $status = Sys::Socket->shutdown($sockfd, $how);
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method socket : void ($sockfd_ref : int*, $domain : int, $type : int, $protocol : int) {
    $$sockfd_ref = Sys::Socket->socket($domain, $type, $protocol);
  }
  
  static method socketpair : int ($sock_fd1_ref : int*, $sock_fd2_ref : int*, $domain : int, $type : int, $protocol : int) {
    my $pair = new int[2];
    
    my $status = Sys::Socket->socketpair($domain, $type, $protocol, $pair);
    
    $$sock_fd1_ref = $pair->[0];
    
    $$sock_fd2_ref = $pair->[1];
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method setsockopt : int ($sockfd : int, $level : int, $optname : int, $optval : object of string|Int) {
    
    unless ($optval) {
      die "\$optval must be defined.";
    }
    
    my $status = -1;
    if ($optval is_type Int) {
      my $optval_ref = [$optval->(Int)->value];
      my $optval_string = new_string_len 4;
      Fn->memcpy($optval_string, 0, $optval_ref, 0, 4);
      
      $status = Sys::Socket->setsockopt($sockfd, $level, $optname, $optval_string, 4);
    }
    elsif ($optval is_type string) {
      my $optval_string = (string)$optval;
      $status = Sys::Socket->setsockopt($sockfd, $level, $optname, $optval_string, length $optval_string);
    }
    else {
      die "The type of \$optval must be Int or string.";
    }
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method getsockopt : string ($sockfd : int, $level : int, $optname : int, $optlen : int = -1) {
    
    unless ($optlen >= 0) {
      $optlen = 4;
    }
    
    my $optval = (mutable string)new_string_len $optlen;
    
    my $status = Sys::Socket->getsockopt($sockfd, $level, $optname, $optval, \$optlen);
    
    my $success = $status == 0;
    
    if ($success) {
      return $optval;
    }
    else {
      return undef;
    }
  }
  
  static method truncate : int ($fd : int, $legnth : long) {
    
    my $status = Sys::IO->ftruncate($fd, $legnth);
    
    my $success = $status == 0;
    
    return $success;
  }
  
  static method sysread : int ($fd : int, $buf : mutable string, $count : int, $buf_offset : int = 0) {
    my $read_length = Sys::IO->read($fd, $buf, $count, $buf_offset);
    return $read_length;
  }
  
  static method syswrite : int ($fd : int, $buf : string, $count : int = -1, $buf_offset : int = 0) {
    my $write_length = Sys::IO->write($fd, $buf, $count, $buf_offset);
    return $write_length;
  }
  
  static method eof : int ($stream : Sys::IO::FileStream) {
    my $eof = Sys::IO->feof($stream);
    return $eof;
  }
  
  static method fileno : int ($stream : Sys::IO::FileStream) {
    my $fd = Sys::IO->fileno($stream);
    return $fd;
  }
}
